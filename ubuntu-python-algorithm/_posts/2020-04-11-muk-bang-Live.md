---
layout: post
title: (Algo) 무지의 먹방 라이브
description: > 
    프로그래머스 무지의 먹방 라이브 문제 풀이
---

문제링크 : [무지의 먹방라이브](https://programmers.co.kr/learn/courses/30/lessons/42891)
### **문제 설명과 최소값 지우기 방법으로 직접 해보기**
![image](https://user-images.githubusercontent.com/46951365/79040791-0c964e80-7c26-11ea-94c5-760a1aa3249d.png)

### Key point
1. k초 직후 = **이미** k번 음식을 씹어 먹었다.
2. 리스트 내부 최솟값 이용할 떄 처리 순서 : 
    + 리스트 내부 원소 지우기 
    + 나머지 모든 원소에 값 빼기  
4. 

### 질문
1. index가 포함된 새로운 리스트를 만들 필요가 있을까?
2. 튜플, 딕셔너리, set 무엇을 사용하는게 좋을까?
3. list는 건들지 않고 k을 더하거나 뺴는 방법은 없을까?
    - 예를 들어, [3 2 2] ---6초 직후--> [1 0 0]  
      == [3 2 2]는 그대로 놔두고, k - 6 ...??? 는 아닌것 같다. 
4. 최솟값 말고 다른 방법은 없을까? 
    - 직접 해보면서 문제점을 찾아보자. -->  우선 나쁘지 않은 듯 하다.  
        -> ***이렇게 내가 컴퓨터다. 라는 마음으로 직접하면서 많이 배운다!!***  
    - 큐? 스택? 다이나믹? 정렬? 

### 해결방법
1. 정직하게 while문을 돌면서, 리스트의 원소들에 -1을 해가는 방법
2. 리스크의 최솟값(가장 빨리 다 먹는 음식)을 찾는다=t   
    - t  *  len(food_times)(=남은 음식 갯수) =< k 이면,  
        - 최솟값을 찾는 행동 계속한다. reculsive하게... 
    - else :
        - 최솟값을 찾는 행동 멈춘다. 
    - 이 방법에는 Dictionary를 이용하는게 낫겠다.  
    - 정확성 테스트 통과 but **효율성에서 시간 초과**. 따라서 이 방법은 적절하지 않다.
3.  

<br>
<br>

## 2번째 해결방법을 이용한 풀이
- 2개의 함수를 만든다  
    - Stop을 위한 함수 
    - reculsive를 위한 함수 (최솟값을 찾는다)  
0. sum(food_times) =< k 이면, return -1 
1. food_times값을 value로 하여, 딕셔너리에 값을 채워 넣는다.
2. while -> dick의 value 중 min값 &nbsp;&nbsp; **VS** &nbsp;&nbsp; k 값  -> 크기 비교
    - if. min*원소갯수 =< k :
        - min인 원소 제거
        - 나머지 원소들의 value - min
        - k = k - min*원소갯수
    - else. min*원소갯수 > k : 
        - (k % 원소갯수)의 그 다음 key 를 return