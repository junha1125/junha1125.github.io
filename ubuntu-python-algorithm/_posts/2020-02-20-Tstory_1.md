---
layout: post
title: 【Python】 2020.02 새로 안 사실
# description: > 
---

(Python) 2020.02 새로 안 사실
## **1. list의 인덱스는 무조건 // 연산자를 써야 한다.**

list[i/2]를 사용하면 에러가 난다. / 연산자를 써서 나오는 결과는 무조건 float형이다. 그게 8/2 = 4.0 이 된다.

따라서 i/2가 4.0이라 할지라도 list[i//2]를 사용해야한다. 

 

## **2. list에서 \* 연산자를 함부러 쓰면 안된다.**

[1] * 10 = [1,1,1,1,1,1,1,1,1,1] 이다.깊은 복사이다. (주소 복사 아님)

하지만 [[1]*2]*3 = [[1,1][1,1][1,1]] 에서 [1,1]들은 모두 얕은 복사이다. (포인터, 참조 복사임)

[1 for i in range(100)] 을 사용하는 것이 유리하다. 

 

순서대로 ABC 



![img](https://k.kakaocdn.net/dn/DlqJA/btqCaeOp1qG/e1f50WctNvSfKxndkZtjPK/img.png)



A : 변수 for는! 

  0을 , 로 나누어 100개 나열해준다. []는 밖의 []가 묶어줌  

  []을 ,로 나누어 100개 나열해준다. []는 밖의 []가 묶어줌 

C : [] *는! <주의!! 리스트 복사만! sallaw copy이다! 주소복사임.. 사용하지 말것> 

  [ ]안에 있는 0을 ,로 나누어 100개 나열하고 []로 묶어 준다. [ 이건 깊은 복사 ] 

  [[ ]]안에 있는 []를 ,로 나누어 100개 나열하고 []로 묶어 준다. [ 이건 얕은 복사] 

  list의 * 연산자는 사용하지 말것. 

 

## **3. list dir tuple을 사용한 함수 매개변수 전달만이 얕은 복사이다.**

만약 output정보를 담을 매개변수를, 외부함수에 전달하고 싶으면 위와 같은 자료형의 변수를 사용해야 한다.

 

## **4. input이 0일 때 항상 문제가 발생한다.**

백준이든 프로그래머스이든 input이 0과 max일 때 꼭 고려하기

 

## **5. sort를 하고 문제를 푼다.**

주어진 문자열 리스트, 숫자 리스트에 대해 sort를 먼저 하는 행위는 시간초과의 위험이 있다. 

하지만 sort를 사용해서 문제를 풀어야 하는 경우도 존재한다. 

sort를 해서 문제를 푸는 것은 가장 마지막 방법으로 생각하자.

 

## **6. 내가 생각할 수 있는 풀이 방법이 이 1개라고 단어하지 말아라.**

문제를 보고 풀이 방법 1개가 생각났다고 하자. 그럼 그 방법으로 풀려고 코딩하지 말아라. 

시점을 바꿔서 다른 방법으로 풀이를 생각해 보아라. 

 

## **7. copy**

얕은 복사 : YES 참조 선언. A is B == True. 서로 id가 같음.

깊은 복사 : NO 참조 선언. A is B == False. 서로 id가 다름.

**좀 더 자세히 공부해보자.** [[이 사이트 정리](https://blueshw.github.io/2016/01/20/shallow-copy-deep-copy/)][[추가 사이트](https://wikidocs.net/16038)]

 

## [**8. 파이썬 객체와 변수**](https://webnautes.tistory.com/1181)

## [**9. copy**](https://blueshw.github.io/2016/01/20/shallow-copy-deep-copy/)

 

\- 파이썬에서 모든 것은 객체이다. 객체는 유일하고 ID는 변하지 않는다. 그 ID가 C처럼 실제 메모리 주소는 아니다.

\- 변수는 그 객체를 가리키는 역할만 한다.

\- 깊은 복사 : copy of value 얕은 복사 : copy of reference

mutable에서는 값이 변하면 객체 그냥 새로 만들어 버린다. 

immutable에서는 단순복사 : copy of reference 얕은 복사 : copy of value + reference 깊은 복사 : copy of value

| **list, set, dict 객체들**                                   | 객체가 만들어진 메모리 공간에 다가가 그 객체 값 **수정 가능(mutble)** | b=a연산자를 통한 복사로, 같은 객체를 가리킨다. 객체가 수정가능하니 b를 위한 새로운 객체를 만들지 않는다. |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **int, float, complex, bool, string, tuple, frozen set 객체들** | 객체가 만들어진 메모리 공간에 다가가 그 객체 값 **수정 불가능(immutble)** | b=a연산자를 통한 복사로, 같은 객체를 가리킨다. 하지만 객체가 수정 불가능하니 b를 위한 새로운 객체를 만든다. |

정수(int)

\- 변수는 객체를 가리킬 뿐이다. 변수에 사칙연산을 하면, 사칙연산 결과의 객체가 새로 생기고, 그 객체를 변수가 가리킨다.

\- 변수가 가리키고 있는 '객체'의 값을 비교하고 싶다면 ==연산자를 사용해야 한다.

\- '객체의 값'이 같더리도 (같은 값을 가지는, 다른 메모리에 위치하는, 2개의 객체) Id가 다를 수 있다. 

\- 0~255의 값을 가지는 객체는 모두 같은 메모리에 위치한다. 이를 제외한 나머지는 모두 바로 위 조건을 따른다.

 

실수(float)

\- '객체의 값'이 같더리도 (같은 값을 가지는, 다른 메모리에 위치하는, 2개의 객체) Id가 다를 수 있다.

-a ~ z, A ~ Z, 0~9, _를 문자열의 요소로 가지는 객체는 모두 같은 메모리에 위치한다. 이를 제외한 나머지는 모두 바로 위 조건을 따른다. (하지만 input으로 받은 문자열은 어떤 값이든 다 다른 메모리에 위치한다.)

 

리스트(list)

\- immutable객체 이므로 위 표의 조건을 따른다. 

\- immutable객체의 경우, 얕은 복사(shallow copy)와 깊은 복사(deep copy)간에 차이가 없다. 앝은 복사(copy.copy(Object)), 깊은 복사(copy.deepcopy(Object))으로 생성한 각각의 객체들은, == 연산자로 true이지만, Id를 확인하면 모두 다른 id이다.

\- 하지만 2차원 이상 list는 얕은 복사와 깊은 복사가 다르다. 얕은 복사를 하면 이 2차원 list([ [**], [**] ])에서 ** 는 참조복사 된다.

\- 2차원 이상의 list도 깊은 복사를 하고 싶으면, list 깊은 복사(deepcopy)를 해줘야 한다. 

 

튜플(tuple)

\- 튜플은 값 수정이 불가능하다. 하지만 같은 값을 가지는 객체 더라도 서로 id가 다르다.

\- 튜플 내부의 원소가 mutable이면, 그 원소는 수정 가능하다. a = ([1, 2, 3]) >> a[0].append(4) 가능! 

 

**항상 mutable한 객체가 문제이다.**

**immutable한 객체는 거의 문제가 되지 않는다. 값이 변하면 '바로 그냥 새로운 메모리 할당!'이라고 생각하자**

 

## **10. 블로그 읽을 때, 마우스 잡지 말기!! -> 집중해서 또박또박 읽기. Just Do It**